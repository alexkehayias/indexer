use sqlite_vec::sqlite3_vec_init;
use tokio_rusqlite::{Connection, Result, ffi::sqlite3_auto_extension};

/// Initialize the db by creating all tables. This function should
/// always succeed and is safe to run multiple times.
pub fn initialize_db(db: &rusqlite::Connection) -> Result<()> {
    // Create a metadata table that has a foreign key to the
    // embeddings virtual table. This will be used to coordinate
    // upserts and hydrating the notes
    let create_note_meta = db.execute(
        r"CREATE TABLE IF NOT EXISTS note_meta (
    -- org-id of the note or hash of the title
    id TEXT PRIMARY KEY,
    -- Source file from storage directory
    file_name TEXT,
    -- Title of the note file or the heading
    title TEXT,
    -- Category
    category TEXT,
    -- Comma separated string of tags
    tags TEXT NULLABLE,
    -- Body of the note in markdown format
    body TEXT,
    -- Type of note e.g. note, meeting, task
    type TEXT,
    -- Task status e.g. todo, done
    status TEXT,
    -- Task scheduled for date yyyy-mm-dd
    scheduled TEXT NULLABLE,
    -- Task deadline date yyyy-mm-dd
    deadline TEXT NULLABLE,
    -- Task closed date yyyy-mm-dd
    closed TEXT NULLABLE,
    -- Meeting date yyyy-mm-dd
    date TEXT NULLABLE
);",
        [],
    );
    match create_note_meta {
        Ok(_) => (),
        Err(e) => println!("Create note meta table failed: {}", e),
    }

    // Create vector virtual table for similarity search
    let create_note_vec_table = db.execute(
        "CREATE VIRTUAL TABLE IF NOT EXISTS vec_items USING vec0(
note_meta_id TEXT PRIMARY KEY,
embedding float[384]
);",
        [],
    );

    match create_note_vec_table {
        Ok(_) => (),
        Err(e) => println!("Create note vec table failed: {}", e),
    };

    // Create vector virtual table for similarity search
    let create_auth_table = db.execute(
        "CREATE TABLE IF NOT EXISTS auth (
    -- This should be the username or email address
    id TEXT PRIMARY KEY,
    -- Name of the service e.g. google
    service TEXT,
    refresh_token TEXT
);",
        [],
    );

    match create_auth_table {
        Ok(_) => (),
        Err(e) => println!("Create auth table failed: {}", e),
    };

    // Create table for tracking push notification subscriptions
    let create_push_subscription_table = db.execute(
        "CREATE TABLE IF NOT EXISTS push_subscription (
    -- Endpoint for the notification service uniquely identifies the client
    endpoint TEXT PRIMARY KEY,
    -- Public key of the client
    p256dh TEXT NOT NULL,
    -- Private key for encrypting notifications
    auth TEXT NOT NULL,
    encoding TEXT NOT NULL DEFAULT 'Aes126Gcm'
);",
        [],
    );

    match create_push_subscription_table {
        Ok(_) => (),
        Err(e) => println!("Create push subscription table failed: {}", e),
    };

    // Create table for storing OpenAI compatible chat completions
    let create_chat_message_table = db.execute(
        "CREATE TABLE IF NOT EXISTS chat_message (
    -- Session ID is a UUID generated by the client
    session_id TEXT,
    -- JSON encoded message data
    data TEXT NOT NULL
);",
        [],
    );

    match create_chat_message_table {
        Ok(_) => (),
        Err(e) => println!("Create chat message table failed: {}", e),
    };

    // Create table for storing session metadata
    let create_session_table = db.execute(
        "CREATE TABLE IF NOT EXISTS session (
    -- Session ID is a UUID generated by the client
    id TEXT PRIMARY KEY,
    -- Timestamp of when the session was created
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    -- Title of the session
    title TEXT,
    -- Summary text for the session
    summary TEXT);",
        [],
    );

    match create_session_table {
        Ok(_) => (),
        Err(e) => println!("Create session table failed: {}", e),
    };

    // Create tag table
    let create_tag_table = db.execute(
        "CREATE TABLE IF NOT EXISTS tag (
    -- Primary key for the tag
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    -- Name of the tag
    name TEXT NOT NULL UNIQUE
);",
        [],
    );

    match create_tag_table {
        Ok(_) => (),
        Err(e) => println!("Create tag table failed: {}", e),
    };

    // Create session_tag linking table
    let create_session_tag_table = db.execute(
        "CREATE TABLE IF NOT EXISTS session_tag (
    -- Foreign key to session table
    session_id TEXT NOT NULL REFERENCES session(id),
    -- Foreign key to tag table
    tag_id INTEGER NOT NULL REFERENCES tag(id),
    -- Primary key constraint for the composite key
    PRIMARY KEY (session_id, tag_id)
);",
        [],
    );

    match create_session_tag_table {
        Ok(_) => (),
        Err(e) => println!("Create session_tag table failed: {}", e),
    };

    // Create table for storing timeseries metric events
    let create_metric_event_table = db.execute(
        "CREATE TABLE IF NOT EXISTS metric_event (
    -- Metric name
    name TEXT NOT NULL,
    -- Timestamp when the event was received (ISO 8601 format)
    timestamp TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    -- Numeric value for the event (e.g., increment amount)
    value INTEGER NOT NULL
);",
        [],
    );

    match create_metric_event_table {
        Ok(_) => (),
        Err(e) => println!("Create metric event table failed: {}", e),
    };

    // Create index on metric_event for efficient queries by id and timestamp
    let create_metric_event_index = db.execute(
        "CREATE INDEX IF NOT EXISTS metric_event_name_timestamp_idx ON metric_event(name, timestamp);",
        [],
    );

    match create_metric_event_index {
        Ok(_) => (),
        Err(e) => println!("Create metric event index failed: {}", e),
    };

    Ok(())
}

/// Migrate the db from a previous schema to a new one. This is NOT
/// safe to run more than once.
pub fn migrate_db(db: &rusqlite::Connection) -> Result<()> {
    // 2024-12-29 Add columns for type and status
    // 2025-03-30 Add column for category
    // 2025-04-05 Add columns for task scheduled, deadline, and
    // closed dates
    let migrated_note_meta_table = db.execute_batch(
        r"BEGIN;

CREATE TABLE IF NOT EXISTS note_meta_new (
    id TEXT PRIMARY KEY,
    file_name TEXT,
    title TEXT,
    category TEXT,
    tags TEXT NULLABLE,
    body TEXT,
    type TEXT DEFAULT 'note',
    status TEXT,
    scheduled TEXT NULLABLE,
    deadline TEXT NULLABLE,
    closed TEXT NULLABLE,
    date TEXT NULLABLE
);

INSERT INTO note_meta_new (id, file_name, title, category, tags, body)
SELECT id, file_name, title, category, tags, body FROM note_meta;

DROP TABLE note_meta;

ALTER TABLE note_meta_new RENAME TO note_meta;

COMMIT;",
    );

    match migrated_note_meta_table {
        Ok(_) => (),
        Err(e) => println!("Create updated note meta table failed: {}", e),
    }

    // 2025-11-26 Add session table and populate with existing chat sessions
    let create_session_table = db.execute(
        "CREATE TABLE IF NOT EXISTS session (
    -- Session ID is a UUID generated by the client
    id TEXT PRIMARY KEY,
    -- Timestamp of when the session was created
    created_at TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    -- Title of the session
    title TEXT,
    -- Summary text for the session
    summary TEXT
);",
        [],
    );

    match create_session_table {
        Ok(_) => (),
        Err(e) => println!("Create session table failed: {}", e),
    };

    // 2025-11-28 Add title and summary columns to session table (migration)
    // This migration adds the new columns to existing sessions
    let add_session_columns = db.execute_batch(
        r"ALTER TABLE session ADD COLUMN title TEXT;
        ALTER TABLE session ADD COLUMN summary TEXT;",
    );

    match add_session_columns {
        Ok(_) => (),
        Err(e) => println!(
            "Add title and summary columns to session table failed: {}",
            e
        ),
    };

    // 2025-11-27 Add tag table and session_tag linking table
    let create_tag_table = db.execute(
        "CREATE TABLE IF NOT EXISTS tag (
    -- Primary key for the tag
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    -- Name of the tag
    name TEXT NOT NULL UNIQUE
);",
        [],
    );

    match create_tag_table {
        Ok(_) => (),
        Err(e) => println!("Create tag table failed: {}", e),
    };

    let create_session_tag_table = db.execute(
        "CREATE TABLE IF NOT EXISTS session_tag (
    -- Foreign key to session table
    session_id TEXT NOT NULL REFERENCES session(id),
    -- Foreign key to tag table
    tag_id INTEGER NOT NULL REFERENCES tag(id),
    -- Primary key constraint for the composite key
    PRIMARY KEY (session_id, tag_id)
);",
        [],
    );

    match create_session_tag_table {
        Ok(_) => (),
        Err(e) => println!("Create session_tag table failed: {}", e),
    };

    // Insert session records for each unique session_id in chat_message table
    let insert_sessions = db.execute_batch(
        r"INSERT OR IGNORE INTO session (id)
        SELECT DISTINCT session_id FROM chat_message WHERE session_id IS NOT NULL;",
    );

    match insert_sessions {
        Ok(_) => (),
        Err(e) => println!("Insert sessions from chat_message failed: {}", e),
    };

    // 2025-11-27 Convert session_id column to foreign key
    // Create a new table with the updated schema and migrate data
    let migrated_chat_message_table = db.execute_batch(
        r"BEGIN;
CREATE TABLE IF NOT EXISTS chat_message_new (
    -- Session ID is a UUID generated by the client
    session_id TEXT NOT NULL REFERENCES session(id),
    -- JSON encoded message data
    data TEXT NOT NULL
);

INSERT INTO chat_message_new (session_id, data)
SELECT session_id, data FROM chat_message;

DROP TABLE chat_message;

ALTER TABLE chat_message_new RENAME TO chat_message;

COMMIT;",
    );

    match migrated_chat_message_table {
        Ok(_) => (),
        Err(e) => println!("Migrate chat message table failed: {}", e),
    };

    Ok(())
}

pub async fn async_db(path_to_db_file: &str) -> anyhow::Result<Connection, anyhow::Error> {
    unsafe {
        sqlite3_auto_extension(Some(std::mem::transmute::<
            *const (),
            unsafe extern "C" fn(
                *mut tokio_rusqlite::ffi::sqlite3,
                *mut *mut i8,
                *const tokio_rusqlite::ffi::sqlite3_api_routines,
            ) -> i32,
        >(sqlite3_vec_init as *const ())));
    }
    let db = Connection::open(format!("{}/vector.db", path_to_db_file)).await;
    Ok(db?)
}
